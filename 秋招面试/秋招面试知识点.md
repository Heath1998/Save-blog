# 秋招面试常见问题

----
## CSS问题

### css单位，详细说一下每一种的使用？ 
   
1.px：绝对单位，页面按精确像素展示

2.em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。

3.rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。

4.vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。

5.vh：viewpoint height，视窗高度，1vh等于视窗高度的1%

### css选择器优先级，说说有几种方法可以超过id选择器？

1. 在属性后面加!important会覆盖任何样式
2. 作为style属性写在元素内的样式
3. id选择器
4. 类选择器
5. 标签选择器
6. 通配选择器

### 讲一下浏览器事件循环机制？宏任务，微任务
浏览器事件循环：首先浏览器是单线程得。所有得同步任务形成一个执行栈。 只要是异步任务，就加入事件队列，当执行栈得同步任务执行完，它就会去事件队列取，这就是事件循环。

如果是浏览器的事件循环，单主线程的同步任务执行完，才会执行微任务中的事件比如promise，
等微任务队列全部执行完毕，才会去执行宏任务队列。

### 讲一下fetch和ajax

Ajax是利用XMLHttpRequest对象来请求数据。

fetch是window的一个方法，主要特点：第一个参数是请求URL，第二个参数是设置初始状态，如get或post方法。 使用了js中的promise对象。

在默认情况下 fetch不会接受或者发送cookies。带cookie 需要手动的指定 credentials:'include'

### 讲一下async/await的原理

async 函数的实现原理，就是将 Generator 函数和自动执行器。
async函数就是generator函数的语法糖。      
你可以想象一下把yield替换成await。   
【async函数对generator的改进】    
(1)内置执行器，不需要使用next()手动执行。   
(2)await命令后面可以是Promise对象或原始类型的值，yield命令后面只能是Thunk函数或Promise对象。    
(3)返回值是Promise。返回非Promise时，async函数会把它包装成Promise返回。(Promise.resolve(value))


1.原理
函数执行时，一旦遇到await就会返回。等到触发的异步操作完成（并且调用栈清空），再接着执行函数体内后面的语句。

### 使用路由做前端拦截的具体实现是什么？
1. 在登陆的时候在本地cookie存储一个isLogin=true，未登录为false；
2. 在路由页router.js里面，写好beforeEach((to, from, next)，根据to.name来判断接下来去那个页面，以及isLogin是否为true；不符合要求的页面全部跳转到login页面；
比如：

### vue-router实现的几种方式和原理？
	

1. hash——即地址栏 URL 中的 # 符号（此 hash 不是密码学里的散列运算）。
比如这个 URL：http://www.abc.com/#/hello，hash 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。
2. history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）
这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。


history模式下，前端的url必须和后端发起请求的url一致，例如http://www.abc.com/boo/id，如果后端缺少对book/id的路由处理，就会返回404错误。


### 讲讲XSS攻击和CSRF攻击的预防

存储型：用户提交字符串，存储到服务器，取出拼接字符串，插入到HTML中    
反射型：利用恶意的url的参数，拼接后插入HTML


存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。

预防这两种漏洞，有两种常见做法：

1. 改成纯前端渲染，把代码和数据分隔开。
2. 对 HTML 做充分转义。

纯前端渲染就是不通过拼接生成html，而是静态html，当有业务数据执行HTML的JavaScript通过Ajax加载数据，更新到页面上

转义 HTML   
如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。   
HTML 的编码是十分复杂的，在不同的上下文里要使用相应的转义规则。

其实只是提高了安全的概率，但是还是有风险的。

如果想更近一步安全的话，需要内容安全策略来保护内容。
比如：   
 禁止加载外域代码，防止复杂的攻击逻辑。  
 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。    
 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。    
 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。    
 合理使用上报可以及时发现 XSS，利于尽快修复问题。

还有控制长度，一般别人攻击都会提交挺长的代码

HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。   
验证码：防止脚本冒充用户提交危险操作。

###  web性能优化
其实你可以从用户输入url经历的过程进行分析。

浏览器缓存：  
首先会检查浏览器缓存，那就可以使用它


DNS解析：   
DNS解析，可以设置meta标签的http-equiv要求DNS预解析，比如遇到超链接就提前解析。   
域名收敛： 就是将静态资源放在一个域名下。减少DNS解析的开销。
域

HTTP连接上：   
常见的减少http请求如静态资源合并，js和css合并，雪碧图就不讲了。   
服务器在完成 HTTP 请求之后不断开 TCP 连接而是挂起，后续有 HTTP 请求可以直接在这个 TCP 连接上发送；缺点是保持长连接会消耗服务端的资源。

HTTP/2 多路复用的特性允许多个 HTTP 请求在同一个 TCP 连接上发送，可以节省多次建立 TCP 连接的时间。


### js的垃圾回收机制

在V8引擎中，js的内存分为新生代和老生代，新生代的对象存活时间较短，老生代的对象基本是常驻对象。   
新生代的垃圾回收主要是：   
1.把新生代内存分为From区和To区  
2.每当有对象产生就放在From区   
3.一旦From区被添满，就触发Scavenge GC。将From区中存活的对象复制到To区。   
4.清空From区    
5.From区和To区交换，开始下一轮。   
其中一个对象多次复制后依然那个存活，它会被认为是生命周期较长的对象，他会晋升到老生代 


老生代垃圾回收：
大多数浏览器都是标记清除
当变量进入执行环境时，就标记为“进入环境”，当变量离开时标记“离开环境”。
垃圾回收器运行时，会在内存中标记所有变量，然后去除环境中的变量以及被环境中变量所引用的变量（闭包），之后标记的变量就是要清除的。

IE是用引用计数的方式清除